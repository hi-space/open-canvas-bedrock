"""
Utility functions for agents.
"""
from typing import Optional, Dict, Any, List
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage
from langchain_core.runnables import RunnableConfig
import uuid
import base64


def format_reflections(
    reflections: Dict[str, Any],
    only_style: bool = False,
    only_content: bool = False
) -> str:
    """Format reflections for use in prompts."""
    if only_style and only_content:
        raise ValueError("Cannot specify both only_style and only_content as true.")

    style_rules = reflections.get("styleRules", [])
    if not isinstance(style_rules, list):
        try:
            import json
            style_rules = json.loads(style_rules) if isinstance(style_rules, str) else []
        except:
            style_rules = []
    
    style_str = "\n- ".join(style_rules) if style_rules else "No style guidelines found."
    
    content_rules = reflections.get("content", [])
    if not isinstance(content_rules, list):
        try:
            import json
            content_rules = json.loads(content_rules) if isinstance(content_rules, str) else []
        except:
            content_rules = []
    
    content_str = "\n- ".join(content_rules) if content_rules else "No memories/facts found."

    style_string = f"""The following is a list of style guidelines previously generated by you:
<style-guidelines>
- {style_str}
</style-guidelines>"""
    
    content_string = f"""The following is a list of memories/facts you previously generated about the user:
<user-facts>
- {content_str}
</user-facts>"""

    if only_style:
        return style_string
    if only_content:
        return content_string

    return style_string + "\n\n" + content_string


def get_model_config(
    config: RunnableConfig,
    is_tool_calling: bool = False
) -> Dict[str, Any]:
    """Get model configuration from config, supporting only AWS Bedrock."""
    from models import DEFAULT_MODEL_NAME
    
    configurable = config.get("configurable", {}) if config else {}
    custom_model_name = configurable.get("customModelName")
    
    # Debug logging
    if not custom_model_name:
        print(f"WARNING: customModelName not found in config. Configurable keys: {list(configurable.keys())}")
        print(f"WARNING: Full config: {config}")
        # Use default model name as fallback
        custom_model_name = DEFAULT_MODEL_NAME
        print(f"WARNING: Using default model name: {custom_model_name}")

    model_config = configurable.get("modelConfig", {})
    
    # Only support AWS Bedrock models
    if not custom_model_name.startswith("bedrock/"):
        raise ValueError(f"Only AWS Bedrock models are supported. Model name must start with 'bedrock/'. Got: {custom_model_name}")
    
    # Remove bedrock/ prefix to get actual model name
    actual_model_name = custom_model_name.replace("bedrock/", "")
    
    return {
        "modelName": actual_model_name,
        "modelProvider": "bedrock",
        "modelConfig": model_config,
        "region": os.getenv("AWS_REGION", "us-east-1"),
        "credentials": {
            "aws_access_key_id": os.getenv("AWS_ACCESS_KEY_ID"),
            "aws_secret_access_key": os.getenv("AWS_SECRET_ACCESS_KEY"),
        }
    }


def format_messages(messages: List[BaseMessage]) -> str:
    """Format messages for display."""
    formatted = []
    for idx, msg in enumerate(messages):
        msg_type = msg.__class__.__name__
        content = msg.content if isinstance(msg.content, str) else str(msg.content)
        formatted.append(f'<{msg_type} index="{idx}">\n{content}\n</{msg_type}>')
    return "\n".join(formatted)


def create_ai_message_from_web_results(web_results: List[Dict[str, Any]]) -> AIMessage:
    """Create an AI message from web search results."""
    web_results_str = "\n\n".join([
        f'''<search-result
      index="{index}"
      publishedDate="{r.get('metadata', {}).get('publishedDate', 'Unknown')}"
      author="{r.get('metadata', {}).get('author', 'Unknown')}"
    >
      [{r.get('metadata', {}).get('title', 'Unknown title')}]({r.get('metadata', {}).get('url', 'Unknown URL')})
      {r.get('pageContent', '')}
    </search-result>'''
        for index, r in enumerate(web_results)
    ])

    content = f"Here is some additional context I found from searching the web. This may be useful:\n\n{web_results_str}"

    return AIMessage(
        content=content,
        id=f"web-search-results-{uuid.uuid4()}",
        additional_kwargs={
            "webSearchResults": web_results,
            "webSearchStatus": "done",
        }
    )


def get_string_from_content(content: Any) -> str:
    """Extract string from message content."""
    if isinstance(content, str):
        return content
    if isinstance(content, list):
        return "\n".join([
            item.get("text", "") if isinstance(item, dict) and "text" in item else str(item)
            for item in content
        ])
    return str(content)


def clean_base64(base64_string: str) -> str:
    """Clean base64 string by removing data URL prefix."""
    return base64_string.replace("data:.*?;base64,", "")


import os

